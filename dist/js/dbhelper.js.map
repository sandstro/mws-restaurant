{"version":3,"sources":["dbhelper.js"],"names":["indexController","IndexController","document","querySelector","DBHelper","callback","_checkDataExists","then","restaurants","length","fetch","DATABASE_URL","response","ok","json","catch","err","error","message","restaurantId","fetchReviews","isFavorite","method","_dbPromise","db","store","transaction","objectStore","get","restaurant","is_favorite","put","object_type","navigator","onLine","myReview","name","review","rating","comment","restaurant_id","body","temp","stringify","Headers","data","resp","headers","indexOf","synchronize","localStorage","window","addEventListener","prototype","slice","call","querySelectorAll","forEach","el","remove","JSON","postReview","removeItem","id","fetchRestaurants","find","r","cuisine","results","filter","cuisine_type","neighborhood","neighborhoods","map","v","i","cuisines","uniqueCuisines","arguments","undefined","hasOwnProperty","photograph","Marker","position","latlng","url","urlForRestaurant","animation"],"mappings":"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","file":"dbhelper.js","sourcesContent":["const indexController = new IndexController(document.querySelector('body'));\r\n\r\n/**\r\n * Common database helper functions.\r\n */\r\nclass DBHelper {\r\n\r\n  /**\r\n   * Database URL.\r\n   */\r\n  static get DATABASE_URL() {\r\n    const port = 1337\r\n    return `http://localhost:${port}`;\r\n  }\r\n\r\n  /**\r\n   * Fetch all restaurants.\r\n   */\r\n  static fetchRestaurants(callback) {\r\n    indexController._checkDataExists().then(restaurants => {\r\n      if (restaurants.length === 0) {\r\n        fetch(`${DBHelper.DATABASE_URL}/restaurants`).then(response => {\r\n          if (response.ok) {\r\n            return response.json();\r\n          }\r\n          throw new Error('Network response was not ok.');\r\n        }).then(json => {\r\n          const restaurants = json;\r\n          indexController._onDataReceived(restaurants);\r\n          callback(null, restaurants);\r\n        }).catch(err => {\r\n          const error = (`Request failed. Returned status of ${err.message}`);\r\n          callback(error, null);\r\n        });\r\n      } else {\r\n        callback(null, restaurants);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Proxy to IndexController.\r\n   */\r\n  static fetchReviews(restaurantId) {\r\n    return indexController.fetchReviews(restaurantId);\r\n  }\r\n\r\n  /**\r\n   * Send restaurant favorite status change to DB.\r\n   */\r\n  static setFavorite(restaurantId, isFavorite) {\r\n    fetch(`${DBHelper.DATABASE_URL}/restaurants/${restaurantId}/?is_favorite=${isFavorite}`, {\r\n      method: 'PUT',\r\n    }).then(() => {\r\n      indexController._dbPromise.then(db => {\r\n        const tx = db.transaction('restaurants', 'readwrite');\r\n        const store = tx.objectStore('restaurants');\r\n        store.get(restaurantId).then(restaurant => {\r\n          restaurant.is_favorite = isFavorite;\r\n          store.put(restaurant);\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Post review to DB.\r\n   */\r\n  static postReview(review) {\r\n    const temp = {\r\n      name: 'temp',\r\n      data: review,\r\n      object_type: 'review',\r\n    };\r\n\r\n    if (!navigator.onLine) {\r\n      DBHelper.synchronize(temp); // Connection lost\r\n      return;\r\n    }\r\n\r\n    const { name, rating, comment, restaurant_id } = review;\r\n    const myReview = { name, rating, comment, restaurant_id };\r\n    fetch(`${DBHelper.DATABASE_URL}/reviews`, {\r\n      method: 'POST',\r\n      body: JSON.stringify(myReview),\r\n      headers: new Headers({\r\n        'Content-Type': 'application/json',\r\n      })\r\n    }).then(resp => {\r\n      if (resp.headers.get('content-type').indexOf('application/json') !== -1) return resp.json();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Use localStorage to set up background sync-ish functionality.\r\n   * This idea came from the webcast for last stage3.\r\n   */\r\n  static synchronize(review) {\r\n    localStorage.setItem('review', JSON.stringify(review.data));\r\n    window.addEventListener('online', () => {\r\n      const data = JSON.parse(localStorage.getItem('review'));\r\n      const offlineLabels = Array.prototype.slice.call(document.querySelectorAll('.restaurant__review__offline__label'));\r\n      offlineLabels.forEach(el => el.remove());\r\n      if (review.name === 'temp') DBHelper.postReview(review.data);\r\n      localStorage.removeItem('review');\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch a restaurant by its ID.\r\n   */\r\n  static fetchRestaurantById(id, callback) {\r\n    // fetch all restaurants with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        const restaurant = restaurants.find(r => r.id == id);\r\n        if (restaurant) { // Got the restaurant.\r\n          callback(null, restaurant);\r\n        } else { // Restaurant does not exist in the database.\r\n          callback('Restaurant does not exist', null);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine type with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisine(cuisine, callback) {\r\n    // Fetch all restaurants  with proper error handling.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given cuisine type.\r\n        const results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n    // Fetch all restaurants.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Filter restaurants to have only given neighborhood.\r\n        const results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n   */\r\n  static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n    // Fetch all restaurants.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        let results = restaurants\r\n        if (cuisine != 'all') { // Filter by cuisine.\r\n          results = results.filter(r => r.cuisine_type == cuisine);\r\n        }\r\n        if (neighborhood != 'all') { // Filter by neighborhood.\r\n          results = results.filter(r => r.neighborhood == neighborhood);\r\n        }\r\n        callback(null, results);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all neighborhoods with proper error handling.\r\n   */\r\n  static fetchNeighborhoods(callback) {\r\n    // Fetch all restaurants.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all neighborhoods from all restaurants.\r\n        const neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n        // Remove duplicates from neighborhoods.\r\n        const uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n        callback(null, uniqueNeighborhoods);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Fetch all cuisines with proper error handling.\r\n   */\r\n  static fetchCuisines(callback) {\r\n    // Fetch all restaurants.\r\n    DBHelper.fetchRestaurants((error, restaurants) => {\r\n      if (error) {\r\n        callback(error, null);\r\n      } else {\r\n        // Get all cuisines from all restaurants.\r\n        const cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n        // Remove duplicates from cuisines.\r\n        const uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n        callback(null, uniqueCuisines);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restaurant page URL.\r\n   */\r\n  static urlForRestaurant(restaurant) {\r\n    return (`./restaurant.html?id=${restaurant.id}`);\r\n  }\r\n\r\n  /**\r\n   * Restaurant image URL.\r\n   */\r\n  static imageUrlForRestaurant(restaurant, wall = false) {\r\n    // Use 10.jpg as a default imgae is photograph missing.\r\n    if (!restaurant.hasOwnProperty('photograph')) {\r\n      restaurant.photograph = '10';\r\n    }\r\n    return (`/img/${restaurant.photograph}.webp`);\r\n  }\r\n\r\n  /**\r\n   * Map marker for a restaurant.\r\n   */\r\n  static mapMarkerForRestaurant(restaurant, map) {\r\n    const marker = new google.maps.Marker({\r\n      position: restaurant.latlng,\r\n      title: restaurant.name,\r\n      url: DBHelper.urlForRestaurant(restaurant),\r\n      map: map,\r\n      animation: google.maps.Animation.DROP}\r\n    );\r\n    return marker;\r\n  }\r\n\r\n}\r\n"]}